
import { collection, getDocs, getDoc, doc, query, where, limit, addDoc, serverTimestamp } from 'firebase/firestore';
import { getFirestore } from 'firebase/firestore';
import { app } from './firebase';
import type { Product as DbProduct, Review } from './db/products';

export interface Product extends DbProduct {
    id: string;
}

// Type for creating a new product. ID will be generated by Firestore.
// Rating and reviews will be empty by default.
type NewProductData = Omit<DbProduct, 'id' | 'rating' | 'reviews'>;

const db = getFirestore(app);
const productsCollection = collection(db, 'products');

export async function getProducts(): Promise<Product[]> {
  const querySnapshot = await getDocs(productsCollection);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Product)).sort((a,b) => b.name.localeCompare(a.name)); // sort is not ideal
}

export async function getFeaturedProducts(): Promise<Product[]> {
  const q = query(productsCollection, where("featured", "==", true));
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Product));
}

export async function getProductById(id: string): Promise<Product | undefined> {
  const docRef = doc(db, "products", id);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    return { id: docSnap.id, ...docSnap.data() } as Product;
  }
  return undefined;
}

export async function getProductsByCategory(category: string): Promise<Product[]> {
    const q = query(productsCollection, where("category", "==", category));
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Product));
}

export async function getRelatedProducts(currentProductId: string, category: string): Promise<Product[]> {
    const q = query(
        productsCollection,
        where("category", "==", category),
        limit(5) // Fetch a few more in case the current product is included
    );
    const querySnapshot = await getDocs(q);
    const relatedProducts = querySnapshot.docs
        .map(doc => ({ id: doc.id, ...doc.data() } as Product))
        .filter(product => product.id !== currentProductId);
        
    return relatedProducts.slice(0, 4); // Return up to 4 related products
}

export async function searchProducts(searchTerm: string): Promise<Product[]> {
    if (!searchTerm.trim()) {
        return [];
    }
    const allProducts = await getProducts();
    const lowerCaseSearchTerm = searchTerm.toLowerCase();

    return allProducts.filter(product => 
        product.name.toLowerCase().includes(lowerCaseSearchTerm) ||
        product.category.toLowerCase().includes(lowerCaseSearchTerm) ||
        product.description.toLowerCase().includes(lowerCaseSearchTerm)
    );
}

export const getCategories = async (): Promise<string[]> => {
    const products = await getProducts();
    const categories = products.map(p => p.category);
    return [...new Set(categories)];
}

export async function createProduct(productData: NewProductData): Promise<Product> {
    const newProduct = {
        ...productData,
        rating: 0,
        reviews: [],
        createdAt: serverTimestamp() // Optional: for sorting by creation time
    }
    const docRef = await addDoc(productsCollection, newProduct);
    return {
        id: docRef.id,
        ...productData,
        rating: 0,
        reviews: []
    };
}


// Re-export types
export type { Product, Review };
