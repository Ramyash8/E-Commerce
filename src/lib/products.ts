
import { collection, getDocs, getDoc, doc, query, where, limit, addDoc, serverTimestamp, updateDoc, deleteDoc } from 'firebase/firestore';
import { getFirestore } from 'firebase/firestore';
import { app } from './firebase';

export interface Review {
  id: string;
  author: string;
  rating: number;
  comment: string;
  date: string;
}
export interface Product {
  id: string;
  name: string;
  price: number;
  description: string;
  images: string[];
  rating: number;
  category: string;
  featured: boolean;
  stock: number;
  reviews: Review[];
  createdAt?: string;
}

// Type for creating a new product. ID will be generated by Firestore.
// Rating and reviews will be empty by default.
type NewProductData = Omit<Product, 'id' | 'rating' | 'reviews'>;
type UpdateProductData = Omit<Product, 'id'>;

const db = getFirestore(app);
const productsCollection = collection(db, 'products');

const convertProductTimestamps = (doc: any) => {
    const data = doc.data();
    if (data.createdAt && typeof data.createdAt.toDate === 'function') {
        data.createdAt = data.createdAt.toDate().toISOString();
    }
    return { id: doc.id, ...data } as Product;
}

export async function getProducts(): Promise<Product[]> {
  const querySnapshot = await getDocs(productsCollection);
  return querySnapshot.docs.map(convertProductTimestamps);
}

export async function getFeaturedProducts(): Promise<Product[]> {
  const q = query(productsCollection, where("featured", "==", true));
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(convertProductTimestamps);
}

export async function getProductById(id: string): Promise<Product | undefined> {
  const docRef = doc(db, "products", id);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    return convertProductTimestamps(docSnap);
  }
  return undefined;
}

export async function getProductsByCategory(category: string): Promise<Product[]> {
    const q = query(productsCollection, where("category", "==", category));
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(convertProductTimestamps);
}

export async function getRelatedProducts(currentProductId: string, category: string): Promise<Product[]> {
    const q = query(
        productsCollection,
        where("category", "==", category),
        limit(5) // Fetch a few more in case the current product is included
    );
    const querySnapshot = await getDocs(q);
    const relatedProducts = querySnapshot.docs
        .map(convertProductTimestamps)
        .filter(product => product.id !== currentProductId);
        
    return relatedProducts.slice(0, 4); // Return up to 4 related products
}

export async function searchProducts(searchTerm: string): Promise<Product[]> {
    if (!searchTerm.trim()) {
        return [];
    }
    const allProducts = await getProducts();
    const lowerCaseSearchTerm = searchTerm.toLowerCase();

    return allProducts.filter(product => 
        product.name.toLowerCase().includes(lowerCaseSearchTerm) ||
        product.category.toLowerCase().includes(lowerCaseSearchTerm) ||
        product.description.toLowerCase().includes(lowerCaseSearchTerm)
    );
}

export const getCategories = async (): Promise<string[]> => {
    const products = await getProducts();
    const categories = products.map(p => p.category);
    return [...new Set(categories)];
}

export async function createProduct(productData: NewProductData): Promise<Product> {
    const newProduct = {
        ...productData,
        rating: 0,
        reviews: [],
        createdAt: serverTimestamp() // Optional: for sorting by creation time
    }
    const docRef = await addDoc(productsCollection, newProduct);
    return {
        id: docRef.id,
        ...productData,
        rating: 0,
        reviews: []
    };
}

export async function updateProduct(productId: string, productData: UpdateProductData): Promise<void> {
    const productRef = doc(db, "products", productId);
    const { id, ...dataToUpdate } = productData; // Exclude id from the data to be updated
    await updateDoc(productRef, dataToUpdate);
}

export async function deleteProduct(productId: string): Promise<void> {
    const productRef = doc(db, "products", productId);
    await deleteDoc(productRef);
}
